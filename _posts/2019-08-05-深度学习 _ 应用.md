---
layout:     post
title:      深度学习 | 应用
subtitle:   大规模深度学习、计算机视觉、语音识别、自然语言处理
date:       2019-08-05
author:     JoselynZhao
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - Deep Learning
---

关注**夏木青**微信公众号，回复关键词**548448**，即可获得《深度学习》第12章应用的原版学习资料（含思维导图）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190803195529125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

# 1 大规模深度学习
深度学习的基本思想是建立在连接机制上的，大量的神经元或者特征作用在一起往往能够表现出智能。

神经网络的进度和处理任务的复杂程度的提升，在一定程度上依赖于网络规模的提升。 事实上，在过去30年里，网络规模是以指数级的速度增长的。
 
**本小节内容按一下六个部分展开讲解。**
1.快速的CPU实现
2. GPU实现
3. 大规模的分布式实现
4. 模型压缩
5. 动态结构
6. 深度网络的专用硬件实现

## 1.1 快速的CPU实现
1、传统做法中，神经网络是用单台机器的 CPU 来训练的，但显然当个CPU无法承担神将网络所需要的巨大的计算量。

2、于是就想到了要设计一些特定的 CPU 上的操作可以大大加快效率。
比如，通过特殊设计的数值运算，我们可以获得巨大的回报。除了选择定点运算或者浮点运算以外，还可以通过优化数据结构来避免高速缓存缺失，使用向量指令。

## 1.2 GPU实现

1、CPU作为图形处理器，是一种特殊设计的硬件，设计的原始目的是为了处理图形应用。

2、对于图像处理问题，显卡必须并行地实现对每个像素的计算来确定每个像素点的颜色。因此，显卡设计为拥有高度并行特性以及很高的内存带宽。

3、但是也有不足之处，如相比于传统的 CPU 更慢的时钟速度以及更弱的处理分支运算的能力。

4、与实时的图形算法相比，神经网络算法需要的是相同的硬件特性。
**高带宽：** 神经网络算法涉及大量的参数，激活值，梯度值通过缓冲区，其中每个值在每一次训练迭代中都要被完全的更新。对于传统的桌面计算机来说，缓冲区是足够大的，所以内存的带宽成为了主要的瓶颈。相比于 CPU，GPU极高的内存带宽成为了一个显著的优势。

**低分支**：神经网络的训练算法通常并不包含分支运算和复杂的控制指令，所以更适用于在 GPU 上训练。

**高并行**：由于同一层神经网络往往能够被分为多个独立处理的神经元，所以 GPU 的并行特性非常有利于神经网络。

5、 使用显卡来训练神经网络的热度在通用 GPU的发布以后开始爆炸性增长。相对简便的编程语言，强大的并行能力以及巨大的内存带宽，通用 GPU是我们神经网络训练的理想平台。

**6、如何在通用 GPU上写高效的代码依然是一个难题。**
在GPU上获得很好表现所需要的技术与 CPU 上的技术有所不同。
GPU代码是多线程的，各个线程之间必须协调好。比如说，如果能够把数据级联 (coalesced)起来，那么涉及内存的操作一般会更快。
为了高效地使用GPU，研究人员需要组织好工作流程，避免对每一个新的模型或算法都编写新的GPU代码。

## 1.3 大规模的分布式实现
在许多情况下，单个机器的计算资源往往是有限的。因此我们希望把训练或者推断的任务分摊到多个机器上进行。

1、分布式的推断是容易实现的，因为每一个输入的样本都可以在单个机器上运行。这也被成为是数据并行 (data parallelism)。

2、同样的，模型并行 (model parallelism) 也是可行的，其中多个机器共同运行一个数据点，每一个机器负责模型的一个部分。

3、但是梯度下降的标准定义完全是一个串行的过程。在第 t 步的梯度是一个第 t -1 步所获得的参数的函数。

4、这个问题可以通过异步随机梯度下降 (Asynchoronous Stochastic Gradient De_x0002_scent) 来解决。
**方法：** 在这个方法中，几个处理器的核共用了存有参数的内存。每一个核在无锁的情况下读取了这个参数，然
后计算其对应的梯度，然后在无锁的状态下更新了这个参数。

**效果：**这种方法减少了每一个梯度下降所获得的平均收益，因为一些核把其它的核所更新的参数（写）覆盖了。
但是因为更新步数的速率增加了，从总体上说还是加快了学习的过程。

## 1.4 模型压缩

在许多商业应用的机器学习模型中，一个时间和内存开销较小的推断算法比一个时间和内存开销较小的训练算法要更为重要。
对于那些不需要个性化设计的应用来说，我们只需要一次性的训练模型，然后它就可以被成千上万的用户使用。

1、减 少 推 断 所 需 要 的 开 销 中 一 个 关 键 的 策 略 是模 型 压 缩 (model compres_x0002_sion)
2、模型压缩的基本思想是用一个更小的模型取代原始耗时的模型，使得用来存储和评估所需的内存和运行时间更少。

3、训练样本的个数是有限的，所以网络的规模也是有限的。只要我们拟合了这个函数f(x)，那么我们可以生成一个拥有了无穷多训练样本的训练集，只需要作用 f 于任意生成的 x。然后，我们使用这些样本来训练一个新的更小的模型。

为了更加充分的利用了这个新的小的模型的表达能力，最好能够从一个类似于真实的测试数据（后面会用到）的分布中采样 x。

## 1.5 动态结构
1、一般来说，加速数据处理系统的一种策略是构造一个系统，这个系统用动态结构 (dynamic structure) 来描述图中处理输入的计算过程。

2、在给定一个输入的情况中，数据处理系统可以动态地决定运行神经网络系统的哪一部分。单个神经网络内部同样也存在了动态结构，来决定特征（隐含层）的哪一部分用于计算。

3、这种神经网络中的动态结构被叫做是**条件计算 (conditional computation)。**
由于模型结构许多部分可能只是跟输入的一小部分有关，只计算那些需要的特征可以起到加速的目的。

4、用于在分类器中加速推断的可行策略是使用**级联 (cascade) 的分类器。**
要确定对象是否存在，我们必须使用具有高容量，运行昂贵的复杂分类器。然而，因为对象是罕见的，我们通常可以使用更少的计算来拒绝不包含对象的输入。

在这些情况下，我们可以训练一系列分类器。
序列中的第一分类器具有低容量，高召回率。换句话说，他们被训练确保当对象存在时，我们不会错误地拒绝输入。
最终训练好的分类器具有高精度。
在测试时，我们按照顺序运行分类器来进行推断，一旦级联中的任何一个元素拒绝它，就选择放弃。

5、这允许我们使用高容量模型以较高的置信度验证对象的存在，而不是强制我们为每个样本付出完全推断的成本。

6、 **决策树**本身是动态结构的一个例子，因为树中的每个节点决定应该使用哪个子树来评估输入。
一个结合深度学习和动态结构的简单方法是训练一个决策树，其中每个节点使用神经网络做出决策
 但这种方法没有实现加速推断计算的目标。

7、我们可以使用称为**选通器 (gater)** 的神经网络来选择在给定当前输入的情况下将使用几个专家网络 (expert network) 中的哪一个来计算输出。
**专家混合体：** 这个想法的第一个版本被称为专家混合体 (mixture of experts)：选通器为每个专家输出一个概率或权重（通过非线性的softmax 函数获得），并且最终输出由各个专家输出的加权组合获得。
**效果**：在这种情况下，使用选通器不会减少计算成本，但如果每个样本的选通器选择单个专家，我们获得一个特殊的硬专家混合体 (hard mixture of experts)，这可以加速推断和训练的时间。

8、另一种动态结构是**开关**，其中隐藏单元可以根据具体情况从不同单元接收输入。
这种动态路由方法可以理解为注意机制 (attention mechanism)
到目前为止，硬开关的使用在大规模应用中还没有被证明是有效的。较为先进的方法一般采用对许多可能的输入使用加权平均，因此不能收获动态结构所有可能的计算益处。

9、使用动态结构化系统的一个**主要障碍**是由于系统针对不同输入的不同代码分支导致的并行度降低。
例如，如果我们分配一台机器来处理级联中的第一步，另一台机器来处理级联中的最后一步，那么第一个机器将倾向于过载，最后一个机器倾向于欠载。如果每个机器被分配以实现神经决策树的不同节点，也会出现类似的问题。


## 1.6 深度网络的专用硬件实现
1、由于更快的硬件产生的巨大影响已经通过GPU的使用得到了证明。单个CPU 或GPU核心的进展速度已经减慢，并且最近计算速度的改进来自于核心的并行化（无论 CPU 还是GPU）, 这都激励着当前对深度网络专用硬件研究。

2、8 和 16 位之间的精度足以满足使用或训练基于反向传播的深度神经网络的要求
数字的一些形式的动态定点表示可以用于减少每个数需要的存储空间
动态固定点表示在一组数字（例如一个层中的所有权重）之间共享该范围
使用固定点代替浮点表示和每个数使用较少的比特能够减少执行乘法所需的硬件表面积，功率需求和计算时间
乘法是使用或训练反向传播的现代深度网络中要求最高法人操作。

# 2 计算机视觉

1、计算机视觉中的深度学习往往用于某种形式的对象识别或检测。

2、尽管图像合成通常不包括在计算机视觉内，但是能够进行图像合成的模型通常用于图像恢复，修复图像中的缺陷或从图像中移除对象这样的计算机视觉任务。

3、本小节内容主要从预处理和数据集增强两个部分来讲。

## 2.1 预处理

1、许多应用领域需要复杂的预处理，因为原始输入以许多深度学习架构难以表示的形式出现。

2、首先，图像应该被标准化。使得它们的像素都在相同并且合理的范围内，比如 [0, 1] 或者 [[ 1, 1]。

3、将图像格式化为具有相同的比例。 严格上说是唯一一种必要的预处理。许多计算机视觉架构需要标准尺寸的图像，因此必须裁剪或缩放图像以适应该尺寸。

4、数据集增强可以被看作是预处理训练集的方式。数据集增强是减少大多数计算机视觉模型泛化误差的一种极好方法。

5、这些预测会被应用到训练集合测试集上，目的是将每个样本置于更规范的形式，以便减少模型需要考虑的变化量。

减少数据中的变化量既能够减少泛化误差，也能够减小拟合训练集所需模型的大小，更简单的任务可以通过更小的模型来解决，而更简单的解决方案泛化能力一般更好。

6、在许多任务中，**对比度**是能够安全移除的最为明显的变化源之一。
我们先来看一下对比度吧。对比度仅指图像中亮像素和暗像素之间差异的大小。量化对比度的方式有很多。在深度学习中，对比度常指的是图像和图像区域中像素的标准差。

7、**全局对比度归一化 (Global contrast normalization, GCN)** 旨在通过从每个图像中减去平均值，然后重新缩放其使得其像素上的标准差等于某个常数 s 来防止图像具有变化的对比度。

全局对比度归一化将确保暗区域的亮度与亮区域的亮度之间存在大的差异，但是，它不能确保暗区内的边缘突出。

8、因此就有了 局部对比度归一化（(local contrast normalization, LCN），局部对比度归一化确保对比度在每个小窗口上被归一化，而不是作为整体在图像上被归一化。关于局部对比度归一化和全局对比度归一化的比较可以参考图12.2。 从图中可以看出，局部对比度归一化更多地改变了原来的图像，丢弃了所有相同强度的区域，使模型只关注于边缘。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805183759795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

- 局部对比度归一化的各种定义都是可行的。在所有情况下，我们可以通过减去邻近像素的平均值并除以邻近像素的标准差来修改每个像素。
- 局部对比度归一化通常可以通过使用可分离卷积（参见第9.8节）来计算特征映射所需要的局部平均值和局部标准差，然后使用元素层面的减法和元素层面的除法实现不同的特征映射。

-  局部对比度归一化是可微分的操作，并且还可以应用于网络隐藏层的非线性作用，以及应用于输入的预处理操作。

- 与全局对比度归一化一样，我们通常需要正则化局部对比度归一化来避免除以零。事实上，因为局部对比度归一化通常作用于较小的窗口，所以正则化更加重要。较小的窗口更可能包含彼此几乎相同的值，因此更可能具有零标准差。


## 2.2 数据集增强


1、数据集增强做为预处理的方式之一，我们前面已经有提到过了。在7.4节中就有提到，通过增加训练集的额外副本来增加训练集的大小，从而改进分类器的泛化能力。


2、对象识别是特别适合于数据集增强的分类任务，因为标签对于许多变换是不变的，可以对输入使用许多几何变换。

3、增强数据集的更高级的变化 还包括图像中颜色的随机扰动 (Krizhevsky et al., 2012b)，以及对输入的非线性几何变形。
# 3 语音识别
1、 语音识别任务将一段包括了自然语言发音的声音信号投影到对应说话人的词序列上。

2、令X= (x(1),x(2),...,x(T)) 表示语音的输入向量，令y=(y1,y2,...,yN)表示目标的输出序列。。自动语音识别(Automatic Speech Recognition, ASR) 任务指的是构造一个函数 f ∗ASR，使得它能够在给定语音序列 X 的情况下计算最有可能的 y 序列：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805183933779.png)
其中 P∗ 是给定输入值 X 时对应目标 y 的条件分布。

3、语音识别研究历史比较久了，我们这里就从深度学习开始。
深度学习应用于神经网络之后显著提高了再TIMIT数据集上的识别率，并将音素级别的错误率从大约26%降到了20.7%。

4、卷积网络在时域与频域上复用了权重，改进了之前的仅在时域上使用重复权值的时延神经网络。
这种新的二维的卷积模型并不是将输入的频谱当作一个长的向量，而是当成是一个图像，其中一个轴对应着时间，另一个轴对应的是谱分量的频率。

5、端到端的深度学习语音识别系统的主要突破是训练了一个深度的长短期记忆的循环神经网络。使用了帧－音素排列的最大后验估计推断。在每一步都有状态变量，每个时间步各层都有状态变量，这个工作把 TIMIT 数据集上音素的错误率降到了记录的新低 17.7%。

6、另一个端到端的深度学习语音识别的最新方法是让系统学习如何利用语音 (phonetic) 层级的信息排列声学 (acoustic) 层级的信息 (Chorowski et al., 2014; Lu et al.,2015)。

# 4 自然语言处理
自然语言处理 (Natural Language Processing) 让计算机学会使用人类语言。
本小节按照以下五个部分分开讲解。
1 n-gram
2 神经语言模型（neural language model，NLM）
3 高维输出
4 结合n-gram和神经语言模型
5 神经机器翻译
## 4.1 n-gram

1、语言模型 (language model) 定义了自然语言中的标记序列的概率分布。

2、根据模型的设计，标记可以是词、字符、甚至是字节，总体来说是离散的实体。

3、最早成功的语言模型是基于固定长度序列的标记模型，称为n-gram。一个n-gram是一个包含 n 个标的序列。

4、基于n-gram的模型定义给定前 n - 1 个标记后的第 n 个标记的条件概率。该模型使用这些条件分布的乘积来定义较长序列的概率分布：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805184051133.png)

5、对于小的 n 值，模型有特定的名称：n = 1 称为一元语法 (unigram)，n = 2 称 为二元语法 (bigram) 及 n = 3 称为三元语法 (trigram)。

6、通常我们同时训练n-gram模型和 n-1 gram 模型。这使得它很容易计算概率：简单地查找两个存储的概率就能计算。

7、举个例子，我们演示三元模型如何计算句子 “THE DOG RAN AWAY.’’ 的概率。
句子的第一个词不能通过上述条件概率的公式计算，因为句子的开头没有上下文。所以，在句子的开头我们必须使用词的边缘概率。因此我们计算 P3(THE DOG RAN)。
最后，可以使用条件分布 P(AWAY | DOG RAN)（典型情况）来预测最后一个词。将这与式(12.6)放在一起，我们得到：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805184137212.png)


8、为了避免概率为0的情况，大多数n-gram模型采用某种形式的平滑 (smoothing)

9、为了提高n-gram模型的统计效率，基于类的语言模型引入词类别的概率，然后属于同一类别的词共享词之间的统计强度。
这个想法使用聚类算法，基于它们与其他词同时出现的频率，将该组词分成集群或类。
尽管词类提供了在序列之间泛化的方式，但其中一些词被相同类的另一个替换，导致该表示丢失了很多信息。
## 4.2 神经语言模型

1、神经语言模型 (Neural Language Model, NLM) 是一类设计用来克服维数灾难的语言模型，它使用词的分布式表示对自然语言序列建模

2、不同于基于类n-gram模型，神经语言模型在识别两个相似的词的基础上，而不丧失将每个词编码为彼此不同的能力。

3、神经语言模型共享一个词（及其上下文）和其他类似词（和上下文之间）的统计强度，模型为每个词学习的分布式表示，允许模型处理具有类似共同特征的词来实现这种共享。

4、维数灾难需要模型泛化到相对句子长度是指数多的句子。该模型通过将每个训练句子与指数数量的类似句子相关联来克服这个问题。

5、我们有时将这些词表示称为词嵌入 (word embedding)。在这个解释下，我们将原始符号视为维度等于词表大小的空间中的点。词表示将这些点嵌入到较低维的特征空间中。
在原始空间中，每个词由一个one-hot向量表示，因此每对词彼此之间的欧氏距离都是 √2。

图12.3放大了学到的词嵌入空间的特定区域，我们可以看到语义上相似的词如何映射到彼此接近的表示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805184235880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

## 4.3 高维输出

这部分内容主要介绍如何处理高维输出的问题。

1、我们会遇到大词汇表的情况，这时，我们可以将词汇表 V 分为最常见词汇（由神经网络处理）的**短列表 (shortlist)** L 和较稀有词汇的尾列表（由n-gram模型处理）。
为了组合这两个预测，神经网络还必须预测在上下文 C 之后出现的词位于尾部列表的概率。

2、减少大词汇表 V 上高维输出层计算负担的经典方法 (Goodman, 2001) 是分层地分解概率。
我们可以认为这种层次结构是先建立词的类别，然后是词类别的类别，然后是词类别的类别的类别，等等这些嵌套类别构成一棵树，其叶上是词。

在这棵树上，树的深度为 log |V|，选择一个词的概率是由路径（从树根到包含该词叶子的路径）
上的每个节点通向该词分支概率的乘积给出。

**分层softmax**的一个重要优点是，它在训练期间和测试期间（如果在测试时我们想计算特定词的概率）都带来了计算的好处。缺点是在实践中，可能因为词类选择得不好，分层softmax倾向于更差的测试结果（相对基于采样的方法）。

3、我们可以从另一个分布中抽样，而不是从模型中抽样，称为提议分布 (pro_x0002_posal distribution)（记为 q），并通过适当的权重来校正从错误分布抽样引入的偏差。

**重要采样 (Importance Sampling)** 不仅可以加速具有较大softmax输出的模型。更一般地，它可以加速具有大稀疏输出层的训练，其中输出是稀疏向量而不是 n 选1.

4、为减少训练大词汇表的神经语言模型计算成本，研究者也提出了其他基于抽样的方法。
将神经语言模型每个词的输出视为一个分数，并试图使正确词的分数 ay 比其他词 ai 排名更高。
提出的**排名损失**则计算如公式12.19所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190805184425208.png)
## 4.4 结合n-gram和神经语言模型

1、n-gram模型相对神经网络的主要优点是n-gram模型具有更高的模型容量（通过存储非常多的元组的频率），并且处理样本只需非常少的计算量（通过查找只匹配当前上下文的几个元组）。

2、 结合n-gram 和神经语言模型是增加容量的一种简单方法。法可以被视为训练具有一组额外输入的神经网络，额外输入直接连接到输出并且不连接到模型的任何其他部分。额外输入是输入上下文中特定n-gram是否存在的指示器，因此这些变量是非常高维且非常稀疏的。
总的来说，模型容量的增加是巨大的（架构的新部分包含高达 |sV |n 个参数），但是处理输
入所需的额外计算量是很小的（因为额外输入非常稀疏）。

## 4.5 神经机器翻译
1、机器翻译以一种自然语言读取句子并产生等同含义的另一种语言的句子。

2、为了使翻译更加灵活，我们希望使用允许输入长度可变和输出长度可变的模型。RNN具备这种能力。
但是使用固定大小的表示来概括非常长的句子（例如 60 个词）的所有语义细节是非常困难的。即使是使用足够大的 RNN，也得用足够长时间训练得很好，才能实现。

3、更高效的方法是先读取整个句子或段落（以获得正在表达的上下文和焦点），然后一次翻译一个词，每次聚焦于输入句子的不同部分来收集产生下一个输出词所需的语义细节。

4、根据刚才的描述，可以实现为一个基于注意机制的系统。我们可以认为基于注意机制的系统有三个组件：
- 读取器 读取原始数据（例如源语句中的源词）并将其转换为分布式表示，其中一个特征向量与每个词的位置相关联。
- 存储器存储读取器输出的特征向量列表。这可以被理解为包含事实序列的存储器，而之后不必以相同的顺序从中检索，也不必访问全部。
- 最后一个程序利用存储器的内容来顺序地执行任务，每个时间步能聚焦于某个存储器元素的内容（或几个，具有不同权重）。

------------------
-----------------------
关注**夏木青**微信公众号，回复关键词**548448**，即可获得《深度学习》第12章应用的原版学习资料（含思维导图）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190803195529125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05HVWV2ZXIxNQ==,size_16,color_FFFFFF,t_70)

